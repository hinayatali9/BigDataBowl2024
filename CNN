import numpy as np
import pandas as pd
import math
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Input, Dense, Conv2D, Conv1D, Activation, BatchNormalization
from tensorflow.keras.layers import MaxPooling2D, MaxPooling1D, AvgPool2D, AvgPool1D, Add, Lambda, LayerNormalization, Dropout
from tensorflow.keras import backend as K
from sklearn.model_selection import train_test_split

tracking1 = pd.read_csv("tracking_week_1.csv")
plays = pd.read_csv("plays.csv")

tracking1.loc[tracking1['playDirection'] == 'left', 'x'] = 120 - tracking1.loc[tracking1['playDirection'] == 'left', 'x']
tracking1.loc[tracking1['playDirection'] == 'left', 'y'] = (160/3) - tracking1.loc[tracking1['playDirection'] == 'left', 'y']
tracking1.loc[tracking1['playDirection'] == 'left', 'dir'] += 180
tracking1.loc[tracking1['dir'] > 360, 'dir'] -= 360
tracking1.loc[tracking1['playDirection'] == 'left', 'o'] += 180
tracking1.loc[tracking1['o'] > 360, 'o'] -= 360

tracking1_with_plays = tracking1.merge(plays, on=['gameId', 'playId'], how='left')
tracking1_with_plays = tracking1_with_plays.loc[tracking1_with_plays['gameId'] == 2022090800]


info = pd.DataFrame()
info_frames = []

for gid in tracking1_with_plays['gameId'].unique():
    game = tracking1_with_plays[tracking1_with_plays['gameId'] == gid].copy()
    for pid in game['playId'].unique():
        play = game[game['playId'] == pid].copy()
        ball_carrier_id = play['ballCarrierId'].iloc[0]
        end_frame_id = play['frameId'].max()
        ball_end_x = play.loc[(play['frameId'] == end_frame_id) & (play['nflId'] == ball_carrier_id), 'x'].iloc[0]
        for fid in play['frameId'].unique():
            frame = play[play['frameId'] == fid].copy()
            frame['is_on_offense'] = frame['club'] == frame['possessionTeam'].iloc[0]
            frame['is_on_defense'] = frame['club'] == frame['defensiveTeam'].iloc[0]
            frame['is_ball_carrier'] = frame['nflId'] == ball_carrier_id
            frame['s_x'] = frame['s']*np.cos(np.deg2rad(frame['dir']))
            frame['s_y'] = frame['s']*np.sin(np.deg2rad(frame['dir']))
            frame['ball_carrier_s_x'] = frame.loc[frame['nflId'] == ball_carrier_id, 's_x'].iloc[0]
            frame['ball_carrier_s_y'] = frame.loc[frame['nflId'] == ball_carrier_id, 's_y'].iloc[0]
            frame['relative_s_x'] = frame['ball_carrier_s_x'] - frame['s_x']
            frame['relative_s_y'] = frame['ball_carrier_s_y'] - frame['s_y']
            frame['ball_carrier_x'] = frame.loc[frame['nflId'] == ball_carrier_id, 'x'].iloc[0]
            frame['relative_x'] = frame['ball_carrier_x'] - frame['x']
            frame['ball_carrier_y'] = frame.loc[frame['nflId'] == ball_carrier_id, 'y'].iloc[0]
            frame['relative_y'] = frame['ball_carrier_y'] - frame['y']
            frame['yards_remaining'] = ball_end_x - frame['ball_carrier_x']
            info_frames.append(frame)
info = pd.concat(info_frames, ignore_index=True)
info.to_csv('info.csv', index=False)

def create_frame_tensor(frame_df):
    offense_players = frame_df[(frame_df['is_on_offense']) & (~frame_df['is_ball_carrier'])].head(10)
    defense_players = frame_df[frame_df['is_on_defense']].head(11)
    tensor_shape = (11, 10, 8)
    tensor = np.zeros(tensor_shape)
    for i, defense_row in enumerate(defense_players.itertuples()):
        for j, offense_row in enumerate(offense_players.itertuples()):
            tensor[i, j, 0] = defense_row.x
            tensor[i, j, 1] = defense_row.y
            tensor[i, j, 2] = defense_row.s_x
            tensor[i, j, 3] = defense_row.s_y
            tensor[i, j, 4] = defense_row.relative_x
            tensor[i, j, 5] = defense_row.relative_y
            tensor[i, j, 6] = defense_row.relative_s_x
            tensor[i, j, 7] = defense_row.relative_s_y

    return tensor

play_frame_tensors = {}

for play_id, play_group in info.groupby('playId'):
    frame_tensors = []
    for frame_id, frame_group in play_group.groupby('frameId'):
        frame_tensor = create_frame_tensor(frame_group)
        if frame_tensor is not None:
            frame_tensors.append((frame_tensor, frame_group['yards_remaining'].iloc[0]))  # Capture yards_remaining for each frame
    play_frame_tensors[play_id] = frame_tensors

train_x = [tensor for tensor, _ in frame_tensors for frame_tensors in play_frame_tensors.values()]
train_y = [yards for _, yards in frame_tensors for frame_tensors in play_frame_tensors.values()]

train_x = np.array(train_x)
train_y = np.array(train_y)

input_dense_players = Input(shape=(11,10,8), name="numerical_players_feature_input")

x = Conv2D(128, kernel_size=(1,1), strides=(1,1))(input_dense_players)
x = Activation('relu')(x)

x = Conv2D(160, kernel_size=(1,1), strides=(1,1))(x)
x = Activation('relu')(x)

x = Conv2D(128, kernel_size=(1,1), strides=(1,1))(x)
x = Activation('relu')(x)

xmax = MaxPooling2D(pool_size=(1,10))(x)
xmax = Lambda(lambda x1: x1 * 0.3)(xmax)

xavg = AvgPool2D(pool_size=(1,10))(x)
xavg = Lambda(lambda x1: x1 * 0.7)(xavg)

x = Add()([xmax, xavg])
x = Lambda(lambda y: K.squeeze(y, 2))(x)
x = BatchNormalization()(x)

x = Conv1D(128, kernel_size=1, strides=1)(x)
x = Activation('relu')(x)
x = BatchNormalization()(x)

x = Conv1D(160, kernel_size=1, strides=1)(x)
x = Activation('relu')(x)
x = BatchNormalization()(x)

x = Conv1D(96, kernel_size=1, strides=1)(x)
x = Activation('relu')(x)
x = BatchNormalization()(x)

xmax = MaxPooling1D(pool_size=11)(x)
xmax = Lambda(lambda x1: x1 * 0.3)(xmax)

xavg = AvgPool1D(pool_size=11)(x)
xavg = Lambda(lambda x1: x1 * 0.7)(xavg)

x = Add()([xmax, xavg])
x = Lambda(lambda y: K.squeeze(y, 1))(x)

x = Dense(96)(x)
x = Activation('relu')(x)
x = BatchNormalization()(x)

x = Dense(256)(x)
x = Activation('relu')(x)
x = BatchNormalization()(x)

out_yards_remaining = Dense(1, activation='linear', name="yards_remaining_output")(x)

model = Model(inputs=[input_dense_players], outputs=[out_yards_remaining])

model.compile(optimizer='adam', loss='mean_squared_error', metrics=['mean_squared_error'])

model.summary()

train_x, val_x, train_y, val_y = train_test_split(train_x, train_y, test_size=0.2, random_state=54)
history = model.fit(x=train_x, y=train_y, epochs=10, batch_size=32, validation_data=(val_x, val_y))

# Evaluate the model on the training data
train_loss, train_mse = model.evaluate(x=train_x, y=train_y)

# Evaluate the model on the validation data
val_loss, val_mse = model.evaluate(x=val_x, y=val_y)

# Print the MSE for training and validation
print(f"Training Mean Squared Error: {train_mse}")
print(f"Validation Mean Squared Error: {val_mse}")
