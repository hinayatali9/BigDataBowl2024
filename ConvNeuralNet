import numpy as np
import pandas as pd
import math

tracking1 = pd.read_csv("tracking_week_1.csv")
plays = pd.read_csv("plays.csv")

tracking1.loc[tracking1['playDirection'] == 'left', 'x'] = 120 - tracking1.loc[tracking1['playDirection'] == 'left', 'x']
tracking1.loc[tracking1['playDirection'] == 'left', 'y'] = (160/3) - tracking1.loc[tracking1['playDirection'] == 'left', 'y']
tracking1.loc[tracking1['playDirection'] == 'left', 'dir'] += 180
tracking1.loc[tracking1['dir'] > 360, 'dir'] -= 360
tracking1.loc[tracking1['playDirection'] == 'left', 'o'] += 180
tracking1.loc[tracking1['o'] > 360, 'o'] -= 360

tracking1_with_plays = tracking1.merge(plays, on=['gameId', 'playId'], how='left')
tracking1_with_plays = tracking1_with_plays[tracking1_with_plays['playNullifiedByPenalty'] == 'N']
tracking1_with_plays['is_on_offense'] = tracking1_with_plays['club'] == tracking1_with_plays['possessionTeam']
tracking1_with_plays['is_on_defense'] = tracking1_with_plays['club'] == tracking1_with_plays['defensiveTeam']
tracking1_with_plays['is_ballcarrier'] = tracking1_with_plays['ballCarrierId'] == tracking1_with_plays['nflId']

train_x = []
identifiers = []
for game_id, game_data in tracking1_with_plays.groupby('gameId'):
    for play_id, play_data in game_data.groupby('playId'):
        for frame_id, frame_data in play_data.groupby('frameId'):
            offense = frame_data[(frame_data['is_on_offense']) & (~frame_data['is_ballcarrier'])]
            defense = frame_data[frame_data['is_on_defense']]
            frame_tensor = np.zeros((11, 10, 10))
            ballcarrier = frame_data[frame_data['is_ballcarrier']]
            ballcarrier_sx = ballcarrier.s * np.cos(np.deg2rad(ballcarrier.dir))
            ballcarrier_sy = ballcarrier.s * np.sin(np.deg2rad(ballcarrier.dir))
            for i, def_player in enumerate(defense.itertuples(index=False)):
                def_player_sx = def_player.s * np.cos(np.deg2rad(def_player.dir))
                def_player_sy = def_player.s * np.sin(np.deg2rad(def_player.dir))
                for j, off_player in enumerate(offense.itertuples(index=False)):
                    off_player_sx = off_player.s * np.cos(np.deg2rad(off_player.dir))
                    off_player_sy = off_player.s * np.sin(np.deg2rad(off_player.dir))
                    frame_tensor[i, j, 0] = off_player.x - def_player.x
                    frame_tensor[i, j, 1] = off_player.y - def_player.y
                    frame_tensor[i, j, 2] = def_player_sx
                    frame_tensor[i, j, 3] = def_player_sy
                    frame_tensor[i, j, 4] = def_player_sx - ballcarrier_sx
                    frame_tensor[i, j, 5] = def_player_sy - ballcarrier_sy
                    frame_tensor[i, j, 6] = def_player.x - ballcarrier.x
                    frame_tensor[i, j, 7] = def_player.y - ballcarrier.y
                    frame_tensor[i, j, 8] = off_player_sx - def_player_sx
                    frame_tensor[i, j, 9] = off_player_sy - def_player_sy
            train_x.append(frame_tensor)
            identifiers.append((game_id, play_id, frame_id))
train_x = np.array(train_x)

train_y = []
for game_id, game_data in tracking1_with_plays.groupby('gameId'):
    for play_id, play_data in game_data.groupby('playId'):
        max_frame = play_data['frameId'].max()
        ball_end_x = play_data.loc[(play_data['frameId'] == max_frame) & (play_data['is_ballcarrier']), 'x'].iloc[0]
        for frame_id, frame_data in play_data.groupby('frameId'):
            ballcarrier_x = frame_data.loc[frame_data['is_ballcarrier'], 'x'].iloc[0]
            yards_remaining = ball_end_x - ballcarrier_x
            train_y.append(yards_remaining)
train_y = np.array(train_y)

!pip install tensorflow
!pip install keras
!pip install scikit-learn

from sklearn.model_selection import GroupKFold
import numpy as np
import tensorflow as tf
from tensorflow.keras.layers import Input, Conv2D, Activation, MaxPooling2D, AvgPool2D, Add, Lambda, BatchNormalization, Conv1D, MaxPooling1D, AvgPool1D, Dense
from tensorflow.keras.models import Model

def create_model():
    input_dense_players = Input(shape=(11,10,4), name="numerical_players_feature_input")

    x = Conv2D(128, kernel_size=(1,1), strides=(1,1))(input_dense_players)
    x = Activation('relu')(x)

    x = Conv2D(160, kernel_size=(1,1), strides=(1,1))(x)
    x = Activation('relu')(x)

    x = Conv2D(128, kernel_size=(1,1), strides=(1,1))(x)
    x = Activation('relu')(x)

    xmax = MaxPooling2D(pool_size=(1,10))(x)
    xmax = Lambda(lambda x1: x1 * 0.3)(xmax)

    xavg = AvgPool2D(pool_size=(1,10))(x)
    xavg = Lambda(lambda x1: x1 * 0.7)(xavg)

    x = Add()([xmax, xavg])
    x = Lambda(lambda y: K.squeeze(y, 2))(x)
    x = BatchNormalization()(x)

    x = Conv1D(128, kernel_size=1, strides=1)(x)
    x = Activation('relu')(x)
    x = BatchNormalization()(x)

    x = Conv1D(160, kernel_size=1, strides=1)(x)
    x = Activation('relu')(x)
    x = BatchNormalization()(x)

    x = Conv1D(96, kernel_size=1, strides=1)(x)
    x = Activation('relu')(x)
    x = BatchNormalization()(x)

    xmax = MaxPooling1D(pool_size=11)(x)
    xmax = Lambda(lambda x1: x1 * 0.3)(xmax)

    xavg = AvgPool1D(pool_size=11)(x)
    xavg = Lambda(lambda x1: x1 * 0.7)(xavg)

    x = Add()([xmax, xavg])
    x = Lambda(lambda y: K.squeeze(y, 1))(x)

    x = Dense(96)(x)
    x = Activation('relu')(x)
    x = BatchNormalization()(x)

    x = Dense(256)(x)
    x = Activation('relu')(x)
    x = BatchNormalization()(x)

    out_yards_remaining = Dense(1, activation='linear', name="yards_remaining_output")(x)

    model = Model(inputs=[input_dense_players], outputs=[out_yards_remaining])

    model.compile(optimizer='adam', loss='mean_squared_error', metrics=['mean_squared_error'])

grouping_variable = [identifier[0] for identifier in identifiers]
n_splits = 5
group_kfold = GroupKFold(n_splits=n_splits)
for fold, (train_index, val_index) in enumerate(group_kfold.split(train_x, train_y, grouping_variable)):
    X_train, X_val = train_x[train_index], train_x[val_index]
    y_train, y_val = train_y[train_index], train_y[val_index]
    model = create_model()
    model.fit(X_train, y_train, validation_data=(X_val, y_val))
